## This Week's Progress
### **TODO**
- [x] Fix a bug in the `distanceBetween` function
- [x] Test with larger datasets to ensure performance and memory usage are acceptable. 
- [ ] Debug `distanceBetween` function (remove loops)
- [ ] Debug `distanceBetween` function (get the shortest distance)
- [x] Create a test data for MLP.
- [x] Implement MLP.
---
### **Fixed a bug in the `distanceBetween` function**

**Issue:**  
When calculating the distance between two nodes (e.g., `"ÁõÆ"` and `"ÊØõ"`), the computation did not terminate and resulted in `exit status 137`.

**Cause:**  
The `.edges` file contained self-referencing edges (i.e., lines where the parent and child were identical), which led to an infinite loop during tree traversal.

**Fix:**  
Added logic in the `loadEdges` function to filter out self-loop entries during edge loading.

```haskell
loadEdges :: 
  FilePath -> -- path to the edges file
  IO [(String, String)] -- load edges from the file
loadEdges path = do
  contents <- readFile path
  let pairs = map parseEdge (filter (not . null) (lines contents))
      filteredPairs = filter (\(p, c) -> p /= c) pairs  -- filter out self-loops
  return filteredPairs
```

**Result:**
With a dataset of 10,000 lines:    

Before the fix:
```haskell
exit status 137
```

After the fix:
```haskell
Path A: entity -> Èï∑ÊâÄ -> Âà©Â∑ß -> ËÅ∞Êòé -> Ë£Å„Åç -> ÁõÆ
Path B: entity -> È¨¢ -> ÊØõ
Distance between ÁõÆ and ÊØõ: 7


Path A: entity -> Ëâ≤ -> Â•≥
Path B: entity -> ÁπãÂêà„Åõ„Çã -> ‰ªòÁùÄ -> Ë≤º„Çã
Distance between Â•≥ and Ë≤º„Çã: 5
```

### Trying with a Larger Dataset

There were redundant entries in the `.edges` data due to duplicates, so I modified the `saveTreeAsEdgeList` function.

I loaded the first 40,000 rows to construct the tree and saved that information into `.edges`.
‚Üí 31,905 pairs exist.

This time, I want to check whether the distanceBetween function works correctly with 40,000 rows, and how long it takes to run.

Some pairs occasionally fail to work:
```
  let nodeA = "Ë≤º„Çã"
      nodeB = "ÈÄöÈÅé"
```
Manually tracing the nodes:
```
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÅãËº∏ ‚Üí ÂÆüÊ•≠ ‚Üí Ë≤øÊòì ‚Üí ÂèñÂõû ‚Üí entity 
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÅãËº∏ ‚Üí ÂÆüÊ•≠ ‚Üí Ë≤øÊòì„ÄÄ‚Üí Âá∫Êù•È´ò ‚Üí entity
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÅãËº∏ ‚Üí ÁßªËª¢ ‚Üí Â§âÊòì ‚Üí entity
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÅãËº∏ ‚Üí ÁßªËª¢ ‚Üí ÈÅãËº∏
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí Âèñ„Å£„Å¶„Åè„Çã
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí ÊåÅ„Å£„Å¶Êù•„Çã ‚Üí ÈÄÅÈÖç
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí ÊåÅ„Å£„Å¶Êù•„Çã ‚Üí ÈÅãËº∏ ‚Üí ÂÆüÊ•≠ ‚Üí Ë≤øÊòì ‚Üí ÂèñÂõû ‚Üí entity 
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí ÊåÅ„Å£„Å¶Êù•„Çã ‚Üí ÈÅãËº∏ ‚Üí ÂÆüÊ•≠  ‚Üí Ë≤øÊòì„ÄÄ‚Üí Âá∫Êù•È´ò ‚Üí entity
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí ÊåÅ„Å£„Å¶Êù•„Çã ‚Üí ÈÅãËº∏ ‚Üí ÁßªËª¢ ‚Üí Â§âÊòì ‚Üí entity
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí ÊåÅ„Å£„Å¶Êù•„Çã ‚Üí ÈÅãËº∏ ‚Üí ÁßªËª¢ ‚Üí ÈÅãËº∏
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí ÊåÅ„Å£„Å¶Êù•„Çã ‚Üí ÈÅãËº∏ ‚Üí ÈÄÅÈÖç ‚Üí ‚Ä¶..
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí ÁßªËª¢ ‚Üí Â§âÊòì ‚Üí entity
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí ÁßªËª¢ ‚Üí ÈÅãËº∏ ‚Üí ÁßªËª¢
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí ÁßªËª¢ ‚Üí ÈÅãËº∏ ‚Üí ÂÆüÊ•≠ ‚Üí Ë≤øÊòì ‚Üí ÂèñÂõû ‚Üí entity 
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí Âèñ„Å£„Å¶„Åè„Çã ‚Üí ÈÄÅÈÖç‚Üí ÁßªËª¢ ‚Üí ÈÅãËº∏ ‚Üí ÂÆüÊ•≠ ‚Üí Ë≤øÊòì„ÄÄ‚Üí Âá∫Êù•È´ò ‚Üí entity
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí ÊåÅ„Å£„Å¶„Åè„Çã
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí ÈÅãËº∏ ‚Üí ÂÆüÊ•≠„ÄÄ‚Üí Ë≤øÊòì ‚Üí ÂèñÂõû ‚Üí entity
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí ÈÅãËº∏ ‚Üí ÂÆüÊ•≠„ÄÄ‚Üí Ë≤øÊòì ‚Üí Âá∫Êù•È´ò ‚Üí entity
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí ÈÅãËº∏ ‚Üí ÁßªËª¢ ‚Üí Â§âÊòì ‚Üí entity
ÈÄöÈÅé ‚Üí ÈÄöË°å„ÄÄ ‚Üí ÈÖçÈÄÅ ‚Üí ÈÅãËº∏ ‚Üí ÁßªËª¢ ‚Üí ÈÅãËº∏
```

It turns out **there is a loop!**   

üåü The distanceBetween function needs to be fixed to account for this.   
üåü The function currently **returns the first found path, not the shortest path**, so that needs to be corrected as well.



### Prepare test data for MLP
Implemented GenerateDatasetMLP.hs.
**Result**
```haskell
Starting dataset generation and splitting...
Generated 2718 positive samples (including transitive relations without 'entity').
Generated 5436 negative samples.
Total samples generated: 8154

Splitting dataset:
  Total samples: 8154
  Training samples: 6523
  Evaluation samples: 1631

Successfully saved 6523 samples to data/MLP/train.csv
Successfully saved 1631 samples to data/MLP/eval.csv
Dataset generation and splitting complete.
```
**Examples of dataset**
```haskell: data/MLP/eval.csv
ÊîØÁµ¶,„Éö„Ç§„É°„É≥„Éà,0
ÁåõÊâì,Ê∞ó„Å•„Åæ„Çä„Åï,0
ÂÇ≤„Çä,ÂìÅÊ†º,1
ÂàÜÁÇπ,Á§ºËÆö,0
Èù¢Êò†„ÇÜ„Åï,ÁãÇ„ÅÑ,1
Âä†ÂÖ•,Â¢óÂ§ß,0
Âç∞Âà∑„Åï„Çå„ÅüË®òÂè∑,ÊØõÂ´å,0
„Åæ„Åò„Å™„ÅÑ,ÊÄù„ÅÑ„ÇÑ„Çä,0
Âæ°Êâã‰ºù„ÅÑ„Åï„Çì,ËÉåÈù¢,0
„Åæ„ÇÜÊ†π,ÊåØ„ÇäÊá∏„Åã„Çã,0
ÂøúÊè¥,Êâì„Å°Âè©„Åè,0
Ê∞óÊ†º,Ê∫Ä„Åü„Åô,0
‰∫∫Â§´,„Éù„Éº„Çø„Éº,1
‰øÆÈ£æ,Ë≠∞Ë´ñ,0
Ë°å„Å™„Çè„Çå„Çã,Â∞Ñ„ÅóÂΩì„Çã,1
Áß∞Êèö,Ë™â„ÇÅ„Å°„Åé„Çã,1
```

**Check**   
If the value of the pair is 0, the Lowest Common Anccestor should be "entity".
```haskell
Enter Node A:
ÊîØÁµ¶
Enter Node B:
„Éö„Ç§„É°„É≥„Éà
Path A: entity -> ÊµÅÈÄö„Åï„Åõ„Çã -> ÊîØÁµ¶
Path B: entity -> ÂøÖË¶ÅÁµåË≤ª -> „Éö„Ç§„É°„É≥„Éà
Distance between ÊîØÁµ¶ and „Éö„Ç§„É°„É≥„Éà: 4

--------------------------------------------

Enter Node A:
ÁåõÊâì
Enter Node B:
Ê∞ó„Å•„Åæ„Çä„Åï
Path A: entity -> Êì≤„Çã -> ÁåõÊâì
Path B: entity -> Èù¢Êò†„ÇÜ„Åï -> Ê∞ó„Å•„Åæ„Çä„Åï
Distance between ÁåõÊâì and Ê∞ó„Å•„Åæ„Çä„Åï: 4
```

If the value of the pair is 1, the Lowest Common Anccestor should be other than "entity".
```haskell
Enter Node A:
ÂÇ≤„Çä
Enter Node B:
ÂìÅÊ†º
Path A: entity -> ÂÇ≤„Çä
Path B: entity -> ÂÇ≤„Çä -> ÂìÅÊ†º
Distance between ÂÇ≤„Çä and ÂìÅÊ†º: 1

--------------------------------------------

Enter Node A:
Áß∞Êèö
Enter Node B:
Ë™â„ÇÅ„Å°„Åé„Çã
Path A: entity -> ÂèØÊ±∫ -> Áß∞Êèö
Path B: entity -> ÂèØÊ±∫ -> Áß∞Êèö -> Ë™â„ÇÅ„Å°„Åé„Çã
Distance between Áß∞Êèö and Ë™â„ÇÅ„Å°„Åé„Çã: 1
```

### Implement MLP
I am trying to implement an MLP with Pre-trained Word Embeddings 

**Pre-trained Word Embeddings Explored**
- fastText    
- Source: [fastText Crawl Vectors](https://fasttext.cc/docs/en/crawl-vectors.html)
- Vocabulary size: 2,000,000
- Vector dimension: 300
- Impression: The vocabulary contained many noisy or poor-quality entries, so I decided not to use it.


**Japanese Wikipedia Entity Vectors**   
- Source: [Jawiki Vector](https://www.cl.ecei.tohoku.ac.jp/~m-suzuki/jawiki_vector/)
- Vocabulary size: 1,015,474
- Vector dimension: 200
- Impression: This dataset seemed to have higher quality vocabulary, so I chose to use this.    

Some words were enclosed in square brackets `[]`, so I wrote a Python script to remove those and used the cleaned data.

---
**Experiment Setup**

I first tried to confirm if the MLP implementation works with a small dataset:

- Word embeddings vocabulary size: 100,000
- Training data size: 1,000
- Evaluation data size: 100

**Results**
```
Loading embeddings...
Loading training data...
Initializing model...
Training...
Iter 50: Loss = NaN
Iter 100: Loss = NaN
Iter 150: Loss = NaN
Iter 200: Loss = NaN
Loading eval data...
Evaluating...
Accuracy: 0.65346533
Precision: NaN
Recall: 0.0
F1 Score: NaN
```

## Possible Causes of Failure

- **Too small vocabulary size in embeddings**  
  ‚Üí Will try the full dataset, but it might take too long.

- **Method of constructing input vectors from the two words may be inappropriate**  
  ‚Üí Currently, I simply concatenate the two 200-dimensional vectors (200 + 200 = 400 dimensions). I should consider improving this approach.    
?????

## TODO
- Add an implementation to plot the learning curve of the loss function
