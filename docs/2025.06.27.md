## This Week's Progress
### **TODO**
- [x] Fix a bug in the `distanceBetween` function
- [x] Test with larger datasets to ensure performance and memory usage are acceptable. 
- [ ] Debug `distanceBetween` function (remove loops)
- [ ] Debug `distanceBetween` function (get the shortest distance)
- [x] Create a test data for MLP.
- [ ] Implement MLP.
---
### **Fixed a bug in the `distanceBetween` function**

**Issue:**  
When calculating the distance between two nodes (e.g., `"ç›®"` and `"æ¯›"`), the computation did not terminate and resulted in `exit status 137`.

**Cause:**  
The `.edges` file contained self-referencing edges (i.e., lines where the parent and child were identical), which led to an infinite loop during tree traversal.

**Fix:**  
Added logic in the `loadEdges` function to filter out self-loop entries during edge loading.

```haskell
loadEdges :: 
  FilePath -> -- path to the edges file
  IO [(String, String)] -- load edges from the file
loadEdges path = do
  contents <- readFile path
  let pairs = map parseEdge (filter (not . null) (lines contents))
      filteredPairs = filter (\(p, c) -> p /= c) pairs  -- filter out self-loops
  return filteredPairs
```

**Result:**
With a dataset of 10,000 lines:    

Before the fix:
```haskell
exit status 137
```

After the fix:
```haskell
Path A: entity -> é•·æ‰€ -> åˆ©å·§ -> è°æ˜ -> è£ã -> ç›®
Path B: entity -> é¬¢ -> æ¯›
Distance between ç›® and æ¯›: 7


Path A: entity -> è‰² -> å¥³
Path B: entity -> ç¹‹åˆã›ã‚‹ -> ä»˜ç€ -> è²¼ã‚‹
Distance between å¥³ and è²¼ã‚‹: 5
```

### Trying with a Larger Dataset

There were redundant entries in the `.edges` data due to duplicates, so I modified the `saveTreeAsEdgeList` function.

I loaded the first 40,000 rows to construct the tree and saved that information into `.edges`.
â†’ 31,905 pairs exist.

This time, I want to check whether the distanceBetween function works correctly with 40,000 rows, and how long it takes to run.

Some pairs occasionally fail to work:
```
  let nodeA = "è²¼ã‚‹"
      nodeB = "é€šé"
```
Manually tracing the nodes:
```
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é‹è¼¸ â†’ å®Ÿæ¥­ â†’ è²¿æ˜“ â†’ å–å› â†’ entity 
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é‹è¼¸ â†’ å®Ÿæ¥­ â†’ è²¿æ˜“ã€€â†’ å‡ºæ¥é«˜ â†’ entity
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é‹è¼¸ â†’ ç§»è»¢ â†’ å¤‰æ˜“ â†’ entity
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é‹è¼¸ â†’ ç§»è»¢ â†’ é‹è¼¸
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ å–ã£ã¦ãã‚‹
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ æŒã£ã¦æ¥ã‚‹ â†’ é€é…
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ æŒã£ã¦æ¥ã‚‹ â†’ é‹è¼¸ â†’ å®Ÿæ¥­ â†’ è²¿æ˜“ â†’ å–å› â†’ entity 
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ æŒã£ã¦æ¥ã‚‹ â†’ é‹è¼¸ â†’ å®Ÿæ¥­  â†’ è²¿æ˜“ã€€â†’ å‡ºæ¥é«˜ â†’ entity
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ æŒã£ã¦æ¥ã‚‹ â†’ é‹è¼¸ â†’ ç§»è»¢ â†’ å¤‰æ˜“ â†’ entity
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ æŒã£ã¦æ¥ã‚‹ â†’ é‹è¼¸ â†’ ç§»è»¢ â†’ é‹è¼¸
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ æŒã£ã¦æ¥ã‚‹ â†’ é‹è¼¸ â†’ é€é… â†’ â€¦..
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ ç§»è»¢ â†’ å¤‰æ˜“ â†’ entity
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ ç§»è»¢ â†’ é‹è¼¸ â†’ ç§»è»¢
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ ç§»è»¢ â†’ é‹è¼¸ â†’ å®Ÿæ¥­ â†’ è²¿æ˜“ â†’ å–å› â†’ entity 
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ å–ã£ã¦ãã‚‹ â†’ é€é…â†’ ç§»è»¢ â†’ é‹è¼¸ â†’ å®Ÿæ¥­ â†’ è²¿æ˜“ã€€â†’ å‡ºæ¥é«˜ â†’ entity
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ æŒã£ã¦ãã‚‹
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ é‹è¼¸ â†’ å®Ÿæ¥­ã€€â†’ è²¿æ˜“ â†’ å–å› â†’ entity
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ é‹è¼¸ â†’ å®Ÿæ¥­ã€€â†’ è²¿æ˜“ â†’ å‡ºæ¥é«˜ â†’ entity
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ é‹è¼¸ â†’ ç§»è»¢ â†’ å¤‰æ˜“ â†’ entity
é€šé â†’ é€šè¡Œã€€ â†’ é…é€ â†’ é‹è¼¸ â†’ ç§»è»¢ â†’ é‹è¼¸
```

It turns out **there is a loop!**   

ğŸŒŸ The distanceBetween function needs to be fixed to account for this.   
ğŸŒŸ The function currently **returns the first found path, not the shortest path**, so that needs to be corrected as well.



### Prepare test data for MLP
Implemented GenerateDatasetMLP.hs.
**Result**
```haskell
Starting dataset generation and splitting...
Generated 2718 positive samples (including transitive relations without 'entity').
Generated 5436 negative samples.
Total samples generated: 8154

Splitting dataset:
  Total samples: 8154
  Training samples: 6523
  Evaluation samples: 1631

Successfully saved 6523 samples to data/MLP/train.csv
Successfully saved 1631 samples to data/MLP/eval.csv
Dataset generation and splitting complete.
```
**Examples of dataset**
```haskell: data/MLP/eval.csv
æ”¯çµ¦,ãƒšã‚¤ãƒ¡ãƒ³ãƒˆ,0
çŒ›æ‰“,æ°—ã¥ã¾ã‚Šã•,0
å‚²ã‚Š,å“æ ¼,1
åˆ†ç‚¹,ç¤¼è®š,0
é¢æ˜ ã‚†ã•,ç‹‚ã„,1
åŠ å…¥,å¢—å¤§,0
å°åˆ·ã•ã‚ŒãŸè¨˜å·,æ¯›å«Œ,0
ã¾ã˜ãªã„,æ€ã„ã‚„ã‚Š,0
å¾¡æ‰‹ä¼ã„ã•ã‚“,èƒŒé¢,0
ã¾ã‚†æ ¹,æŒ¯ã‚Šæ‡¸ã‹ã‚‹,0
å¿œæ´,æ‰“ã¡å©ã,0
æ°—æ ¼,æº€ãŸã™,0
äººå¤«,ãƒãƒ¼ã‚¿ãƒ¼,1
ä¿®é£¾,è­°è«–,0
è¡Œãªã‚ã‚Œã‚‹,å°„ã—å½“ã‚‹,1
ç§°æš,èª‰ã‚ã¡ãã‚‹,1
```

**Check**   
If the value of the pair is 0, the Lowest Common Anccestor should be "entity".
```haskell
Enter Node A:
æ”¯çµ¦
Enter Node B:
ãƒšã‚¤ãƒ¡ãƒ³ãƒˆ
Path A: entity -> æµé€šã•ã›ã‚‹ -> æ”¯çµ¦
Path B: entity -> å¿…è¦çµŒè²» -> ãƒšã‚¤ãƒ¡ãƒ³ãƒˆ
Distance between æ”¯çµ¦ and ãƒšã‚¤ãƒ¡ãƒ³ãƒˆ: 4

--------------------------------------------

Enter Node A:
çŒ›æ‰“
Enter Node B:
æ°—ã¥ã¾ã‚Šã•
Path A: entity -> æ“²ã‚‹ -> çŒ›æ‰“
Path B: entity -> é¢æ˜ ã‚†ã• -> æ°—ã¥ã¾ã‚Šã•
Distance between çŒ›æ‰“ and æ°—ã¥ã¾ã‚Šã•: 4
```

If the value of the pair is 1, the Lowest Common Anccestor should be other than "entity".
```haskell
Enter Node A:
å‚²ã‚Š
Enter Node B:
å“æ ¼
Path A: entity -> å‚²ã‚Š
Path B: entity -> å‚²ã‚Š -> å“æ ¼
Distance between å‚²ã‚Š and å“æ ¼: 1

--------------------------------------------

Enter Node A:
ç§°æš
Enter Node B:
èª‰ã‚ã¡ãã‚‹
Path A: entity -> å¯æ±º -> ç§°æš
Path B: entity -> å¯æ±º -> ç§°æš -> èª‰ã‚ã¡ãã‚‹
Distance between ç§°æš and èª‰ã‚ã¡ãã‚‹: 1
```

