## This Week's Progress
### **TODO**
- [x] Fix a bug in the `distanceBetween` function
- [x] Test with larger datasets to ensure performance and memory usage are acceptable. 
- [ ] Debug `distanceBetween` function (remove loops)
- [ ] Debug `distanceBetween` function (get the shortest distance)
- [ ] Create a comprehensive set of test data.
- [ ] Implement MLP.
---
### **Fixed a bug in the `distanceBetween` function**

**Issue:**  
When calculating the distance between two nodes (e.g., `"目"` and `"毛"`), the computation did not terminate and resulted in `exit status 137`.

**Cause:**  
The `.edges` file contained self-referencing edges (i.e., lines where the parent and child were identical), which led to an infinite loop during tree traversal.

**Fix:**  
Added logic in the `loadEdges` function to filter out self-loop entries during edge loading.

```haskell
loadEdges :: 
  FilePath -> -- path to the edges file
  IO [(String, String)] -- load edges from the file
loadEdges path = do
  contents <- readFile path
  let pairs = map parseEdge (filter (not . null) (lines contents))
      filteredPairs = filter (\(p, c) -> p /= c) pairs  -- filter out self-loops
  return filteredPairs
```

**Result:**
With a dataset of 10,000 lines:    

Before the fix:
```haskell
exit status 137
```

After the fix:
```haskell
Path A: entity -> 長所 -> 利巧 -> 聰明 -> 裁き -> 目
Path B: entity -> 鬢 -> 毛
Distance between 目 and 毛: 7


Path A: entity -> 色 -> 女
Path B: entity -> 繋合せる -> 付着 -> 貼る
Distance between 女 and 貼る: 5
```

### Trying with a Larger Dataset

There were redundant entries in the `.edges` data due to duplicates, so I modified the `saveTreeAsEdgeList` function.

I loaded the first 40,000 rows to construct the tree and saved that information into `.edges`.
→ 31,905 pairs exist.

This time, I want to check whether the distanceBetween function works correctly with 40,000 rows, and how long it takes to run.

Some pairs occasionally fail to work:
```
  let nodeA = "貼る"
      nodeB = "通過"
```
Manually tracing the nodes:
```
通過 → 通行　 → 配送 → 取ってくる → 運輸 → 実業 → 貿易 → 取回 → entity 
通過 → 通行　 → 配送 → 取ってくる → 運輸 → 実業 → 貿易　→ 出来高 → entity
通過 → 通行　 → 配送 → 取ってくる → 運輸 → 移転 → 変易 → entity
通過 → 通行　 → 配送 → 取ってくる → 運輸 → 移転 → 運輸
通過 → 通行　 → 配送 → 取ってくる → 送配→ 取ってくる
通過 → 通行　 → 配送 → 取ってくる → 送配→ 持って来る → 送配
通過 → 通行　 → 配送 → 取ってくる → 送配→ 持って来る → 運輸 → 実業 → 貿易 → 取回 → entity 
通過 → 通行　 → 配送 → 取ってくる → 送配→ 持って来る → 運輸 → 実業  → 貿易　→ 出来高 → entity
通過 → 通行　 → 配送 → 取ってくる → 送配→ 持って来る → 運輸 → 移転 → 変易 → entity
通過 → 通行　 → 配送 → 取ってくる → 送配→ 持って来る → 運輸 → 移転 → 運輸
通過 → 通行　 → 配送 → 取ってくる → 送配→ 持って来る → 運輸 → 送配 → …..
通過 → 通行　 → 配送 → 取ってくる → 送配→ 移転 → 変易 → entity
通過 → 通行　 → 配送 → 取ってくる → 送配→ 移転 → 運輸 → 移転
通過 → 通行　 → 配送 → 取ってくる → 送配→ 移転 → 運輸 → 実業 → 貿易 → 取回 → entity 
通過 → 通行　 → 配送 → 取ってくる → 送配→ 移転 → 運輸 → 実業 → 貿易　→ 出来高 → entity
通過 → 通行　 → 配送 → 持ってくる
通過 → 通行　 → 配送 → 運輸 → 実業　→ 貿易 → 取回 → entity
通過 → 通行　 → 配送 → 運輸 → 実業　→ 貿易 → 出来高 → entity
通過 → 通行　 → 配送 → 運輸 → 移転 → 変易 → entity
通過 → 通行　 → 配送 → 運輸 → 移転 → 運輸
```

It turns out **there is a loop!**   

🌟 The distanceBetween function needs to be fixed to account for this.   
🌟 The function currently **returns the first found path, not the shortest path**, so that needs to be corrected as well.




